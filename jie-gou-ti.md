# 结构体

在Go中，结构体（struct）就是一个字段的集合，通过如下方式定义:

```go
type Vertex struct {
	X int
	Y int
}
```
结构体字段通过点号（`.`）来**访问**，在通过结构体指针访问字段时也是使用点号，即指针的间接访问是透明的。

```go
p := &Vertex{1, 2}
p.X = 1e9
fmt.Println(p.Y)
```

结构体**初始化**： 使用`Name:`语法初始化结构体字段。

```go
var (
	v1 = Vertex{1, 2}  // 类型为 Vertex
	v2 = Vertex{X: 1}  // Y:0 被省略
	v3 = Vertex{}      // X:0 和 Y:0
	p  = &Vertex{1, 2} // 类型为 *Vertex
)
```

**注意**：如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。

一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适应于数组。）但是S类型的结构体可以包含`*S`指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。

如果结构体没有任何成员的话就是**空结构体**，写作`struct{}`。它的大小为0，也不包含任何信息，但是有时候依然是有价值的。有些Go语言程序员用map带模拟set数据结构时，用它来代替map中布尔类型的value，只是强调key的重要性，但是因为节约的空间有限，而且语法比较复杂，所有我们通常避免避免这样的用法。

```go
seen := make(map[string]struct{}) // set of strings
// ...
if _, ok := seen[s]; !ok {
    seen[s] = struct{}{}
    // ...first time seeing s...
}
```
## 结构体字面量

结构体可以用结构体字面量初始化，初始化时结构体字面量可以指定每个成员的值。

```go
type Point struct { X, Y int }
p := Point{1, 2} // 第一种写法，需记忆顺序，调整字段顺序编译失败
p := Point{X: 1, Y: 2} // 第二种写法
```

## 结构体的传递

如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回，如果要在函数内部修改结构体成员的话，用指针传入是必须的；因为在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。



